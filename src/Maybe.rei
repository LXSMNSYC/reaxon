let ambArray: array(MaybeTypes.s('source, 'a)) => MaybeTypes.operator('downstream, 'a);
let ambList: list(MaybeTypes.s('source, 'a)) => MaybeTypes.operator('downstream, 'a);
let ambWith: MaybeTypes.s('other, 'a) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let cache: MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let concatArray: array(MaybeTypes.s('source, 'a)) => ObservableTypes.operator('downstream, 'a);
let concatList: list(MaybeTypes.s('source, 'a)) => ObservableTypes.operator('downstream, 'a);
let concatWith: MaybeTypes.s('other, 'a) => MaybeTypes.s('source, 'a) => ObservableTypes.operator('downstream, 'a);
let contains: 'a => ('a => 'a => bool) => MaybeTypes.s('source, 'a) => SingleTypes.operator('downstream, bool);
let count: MaybeTypes.s('source, 'a) => SingleTypes.operator('downstream, int);
let defaultIfEmpty: 'a => MaybeTypes.s('source, 'a) => SingleTypes.operator('downstream, 'a);
let defer: (unit => MaybeTypes.s('source, 'a)) => MaybeTypes.operator('downstream, 'a);
let delay: int => Scheduler.t => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let delaySubscription: int => Scheduler.t => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let delayUntil: MaybeTypes.s('other, 'a) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let dematerialize: SingleTypes.s('source, Notification.Maybe.t('a)) => MaybeTypes.operator('downstream, 'a);
let doAfterSuccess: ('a => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let doAfterTerminate: (unit => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let doFinally: (unit => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let doOnCancel: (unit => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let doOnComplete: (unit => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let doOnError: (exn => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let doOnEvent: (option('a) => option(exn) => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let doOnSubscribe: (MaybeTypes.subscription => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let doOnSuccess: ('a => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let doOnTerminate: (unit => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let empty: unit => MaybeTypes.operator('downstream, 'a);
let equals: MaybeTypes.s('left, 'a) => MaybeTypes.s('right, 'b) => ('a => 'b => bool) => SingleTypes.operator('downstream, bool);
let error: exn => MaybeTypes.operator('downstream, 'a);
let filter: ('a => bool) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let flatMap: ('a => MaybeTypes.s('other, 'b)) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'b);
let flatMapCompletable: ('a => CompletableTypes.s('result)) => MaybeTypes.s('source, 'a) => CompletableTypes.operator('downstream);
let flatMapObservable: ('a => ObservableTypes.s('result, 'a)) => MaybeTypes.s('source, 'a) => ObservableTypes.operator('downstream, 'a);
let flatMapSingle: ('a => SingleTypes.s('result, 'a)) => MaybeTypes.s('source, 'a) => SingleTypes.operator('downstream, 'a);
let flatMapSingleElement: ('a => SingleTypes.s('result, 'a)) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let flattenToArrayObservable: ('a => array('a)) => MaybeTypes.s('source, 'a) => ObservableTypes.operator('downstream, 'a);
let flattenToListObservable: ('a => list('a)) => MaybeTypes.s('source, 'a) => ObservableTypes.operator('downstream, 'a);
let fromAction: (unit => unit) => MaybeTypes.operator('downstream, 'a);
let fromCompletable: CompletableTypes.s('source) => MaybeTypes.operator('downstream, 'a);
let fromObservable: ObservableTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let fromSingle: SingleTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let fromSupplier: (unit => 'a) => MaybeTypes.operator('downstream, 'a);
let hide: MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let isEmpty: MaybeTypes.s('source, 'a) => SingleTypes.operator('downstream, bool);
let just: 'a => MaybeTypes.operator('downstream, 'a);
let lift: (MaybeTypes.observer('downstream, 'a) => MaybeTypes.observer('result, 'b)) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'b);
let make: (MaybeTypes.emitter({
  .
  isCancelled: unit => bool,
  setCancellable: Cancellable.t({..}) => unit,
  onComplete: unit => unit,
  onSuccess: 'a => unit,
  onError: exn => unit,
}, 'a) => unit) => MaybeTypes.operator('downstream, 'a);
let map: ('a => 'b) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'b);
let materialize: MaybeTypes.s('source, 'a) => SingleTypes.operator('downstream, Notification.Maybe.t('a));
let merge: MaybeTypes.s('source, MaybeTypes.s('result, 'a)) => MaybeTypes.operator('downstream, 'a);
let mergeArray: array(MaybeTypes.s('source, 'a)) => ObservableTypes.operator('downstream, 'a);
let mergeList: list(MaybeTypes.s('source, 'a)) => ObservableTypes.operator('downstream, 'a);
let mergeWith: MaybeTypes.s('other, 'a) => MaybeTypes.s('source, 'a) => ObservableTypes.operator('downstream, 'a);
let never: unit => MaybeTypes.operator('downstream, 'a);
let observeOn: Scheduler.t => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let onErrorComplete: MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let onErrorCompleteWhen: (exn => bool) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let onErrorResume: (exn => MaybeTypes.s('backup, 'a)) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let onErrorResumeNext: MaybeTypes.s('backup, 'a) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let onErrorReturn: (exn => 'a) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let onErrorReturnItem: 'a => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let repeat: MaybeTypes.s('source, 'a) => ObservableTypes.operator('downstream, 'a);
let repeatCount: int => MaybeTypes.s('source, 'a) => ObservableTypes.operator('downstream, 'a);
let repeatUntil: (int => bool) => MaybeTypes.s('source, 'a) => ObservableTypes.operator('downstream, 'a);
let retry: MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let retryCount: int => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let retryUntil: (int => bool) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a) ;
let retryWhile: (int => exn => bool) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let subscribe: ('a => unit) => (unit => unit) => (exn => unit) => MaybeTypes.s('source, 'a) => MaybeTypes.subscription;
let subscribeOn: Scheduler.t => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let switchIfEmpty: MaybeTypes.s('other, 'a) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let switchIfEmptySingle: SingleTypes.s('other, 'a) => MaybeTypes.s('source, 'a) => SingleTypes.operator('downstream, 'a);
let takeUntil: MaybeTypes.s('other, 'a) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let timeout: int => Scheduler.t => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let timer: int => Scheduler.t => MaybeTypes.operator('downstream, int);
let toCompletable: MaybeTypes.s('source, 'a) => CompletableTypes.operator('downstream);
let toObservable: MaybeTypes.s('source, 'a) => ObservableTypes.operator('downstream, 'a);
let toSingle: MaybeTypes.s('source, 'a) => SingleTypes.operator('downstream ,'a);
let toSingleDefault: 'a => MaybeTypes.s('source, 'a) => SingleTypes.operator('downstream, 'a);
let unsubscribeOn: Scheduler.t => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'a);
let zipArray: array(MaybeTypes.s('source, 'a)) => (array('a) => 'b) => MaybeTypes.operator('downstream, 'b);
let zipList: list(MaybeTypes.s('source, 'a)) => (array('a) => 'b) => MaybeTypes.operator('downstream, 'b);
let zipWith: MaybeTypes.s('other, 'a) => ('a => 'a => 'b) => MaybeTypes.s('source, 'a) => MaybeTypes.operator('downstream, 'b);